<!doctype html><html lang="ja"><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>TRIW記事</title>
<style>
  body{font:16px/1.7 system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;margin:24px;color:#222}
  main{max-width:900px;margin:auto}
  a{color:#0366d6;text-decoration:none}a:hover{text-decoration:underline}
  pre{overflow:auto;background:#f6f8fa;padding:12px;border-radius:6px}
  h1{font-size:1.8rem;margin:0 0 1rem}
  hr{margin:2rem 0}
  main img {
    display: block;               /* 余白の制御を安定 */
    max-width: 100%;              /* はみ出し防止 */
    height: auto;
    border: 1px solid #c9d1d9;    /* ← 罫線（薄いグレー） */
    border-radius: 6px;           /* 角丸（不要なら消してOK） */
    background: #fff;             /* 透過PNGでも下地を白に */
    box-sizing: border-box;
    margin: 8px 0 32px;               /* 上下に余白 */
  }

/* リンクになっている画像にも同じ枠線を適用（保険） */
  main a > img {
    border: 1px solid #c9d1d9;
    border-radius: 6px;
  }
/* 前へ / 次へ ナビ */
.nav-pager{
  display:flex; justify-content:space-between; gap:12px;
  align-items:center; margin:32px 0 8px;
}
.nav-pager a{
  display:inline-block; padding:8px 12px; border:1px solid #e1e4e8;
  border-radius:8px; text-decoration:none;
}
.nav-pager a:hover{ background:#f6f8fa }
.nav-pager .spacer{ flex:1 }

</style>
<main id="app">読み込み中…</main>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
  const el = document.getElementById('app');
  const file = new URLSearchParams(location.search).get('file');

  function cleanMarkdown(md) {
    if (/^---\s*\r?\n/.test(md)) md = md.replace(/^---\s*[\s\S]*?\r?\n---\s*\r?\n?/, '');
    md = md.replace(/^(?:layout:.*|title:.*)\s*\r?\n/gi, '');
    md = md.replace(/^\s*\[TOC\]\s*$/gmi, '');
    return md.trimStart();
  }

  (async () => {
    try {
      if (!file) throw new Error("file パラメータが必要です");
      const res = await fetch(file, { cache: 'no-store' });
      if (!res.ok) throw new Error(`取得失敗: ${file}`);
      const base = new URL(file, location.href);      // ← 章ファイルの場所
      const md = cleanMarkdown(await res.text());
      el.innerHTML = marked.parse(md);

      // 1) a要素のリンク補正（.md は自分で開く）
      [...el.querySelectorAll('a[href]')].forEach(a => {
        const href = a.getAttribute('href');
        if (!href || href.startsWith('#') || /^https?:/i.test(href)) return;
        const url = new URL(href, base);
        if (url.pathname.endsWith('.md')) {
          a.href = `${location.pathname}?file=${decodeURIComponent(url.pathname.replace(/^\/triw-writing\//,'')).replace(/^\//,'')}`;
        } else {
          a.href = url.href; // 絶対URLに正規化
        }
      });

      // 2) 画像のsrc補正（章ファイル基準で絶対URLに）
      [...el.querySelectorAll('img[src]')].forEach(img => {
        try {
          const src = img.getAttribute('src');
          if (!src || /^https?:/i.test(src) || src.startsWith('data:')) return;
          const url = new URL(src, base);
          img.src = url.href;
          img.loading = 'lazy';
          img.decoding = 'async';
        } catch {}
      });
    } catch (e) {
      el.innerHTML = `<p>エラー: ${e.message}</p>`;
    }
      async function loadTocList(repoRoot) {
    const res = await fetch(`${repoRoot}/index.md`, { cache: 'no-store' });
    if (!res.ok) throw new Error('index.md を取得できませんでした');
    const text = await res.text();
    // 目次セクションの [text](path.md) を抽出
    const mdLinks = [...text.matchAll(/\[([^\]]+)\]\(([^)]+\.md)\)/g)]
      .map(m => ({ title: m[1], path: m[2].replace(/^\.\//,'') }));
    // 同じ章が重複しても一意に
    const seen = new Set();
    const toc = mdLinks.filter(x => {
      const k = x.path;
      if (seen.has(k)) return false;
      seen.add(k);
      return true;
    });
    return toc;
  }

  // 前後リンクを作って挿入
  function insertPrevNext(toc, currentPath, repoRoot) {
    const idx = toc.findIndex(x => x.path === currentPath);
    if (idx === -1) return;
    const prev = idx > 0 ? toc[idx - 1] : null;
    const next = idx < toc.length - 1 ? toc[idx + 1] : null;

    const nav = document.createElement('nav');
    nav.className = 'nav-pager';
    nav.innerHTML = `
      ${prev ? `<a href="${repoRoot}/reader.html?file=${encodeURIComponent(prev.path)}">← ${prev.title}</a>` : `<span></span>`}
      <span class="spacer"></span>
      ${next ? `<a href="${repoRoot}/reader.html?file=${encodeURIComponent(next.path)}">${next.title} →</a>` : `<span></span>`}
    `;
    // 上と下に挿入
    const main = document.getElementById('app');
    main.prepend(nav.cloneNode(true));
    main.appendChild(nav);
  }

  (async () => {
    // 既存のレンダリング処理の中で…
    // base, md の描画などはそのまま
    // 例）el.innerHTML = marked.parse(md);

    // repo ルート（/triw-writing）を算出
    const parts = location.pathname.split('/').filter(Boolean);
    const repoRoot = parts.length ? '/' + parts[0] : '';

    // 現在の章ファイルの相対パス（/triw-writing/ を除去）
    const fileParam = new URLSearchParams(location.search).get('file') || '';
    const currentPath = fileParam.replace(/^\/?triw-writing\//,'').replace(/^\//,'');

    try {
      const toc = await loadTocList(repoRoot);
      insertPrevNext(toc, currentPath, repoRoot);
    } catch (e) {
      console.warn('前後リンク生成をスキップ:', e);
    }
  })();

</script>

</html>
